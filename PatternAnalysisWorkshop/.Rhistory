#| label: variogram_parameters
range.init <- 1000  # estimated range, m
cutoff.init <- range.init*5  # cutoff for empirical variogram, m
width.init <- 250   # bin width
#| label: variogram_empirical
#| fig-width: 8
#| fig-height: 4
names(sg4.sf[[1]])
# give the `sf` object a simple name, also the target variable
var <- sg4.sf[[1]]
names(var)[1] <- "z"
v.sg <- variogram(z ~ 1, loc = var,
cutoff=cutoff.init, width=width.init)
#
plot(v.sg, main = layer.names[1])
#| label: variogram_model
vm.sg <- vgm(0.8*max(v.sg$gamma), "Exp", range.init, 0)
print(vmf.sg <- fit.variogram(v.sg, model=vm.sg))
#| label: fitted_variogram_model
#| fig-width: 8
#| fig-height: 4
plot(v.sg, model=vmf.sg, main = layer.names[1],
xlab = "separation m", ylab = expression(paste(Delta, plain(pH)^2)))
make.weights <- function(n = 5, res = 250, vgm) {
m <- matrix(0, nrow = n, ncol = n)
center <- ceiling(n / 2)
for (i in 1:n) {
for (j in 1:n) {
# distance in cell units, multipled by the grid resolution
m[i, j] <- sqrt((i - center)^2 + (j - center)^2)*250
}
}
w <- 1 - variogramLine(vm.sg, dist_vector = m)
return(w)
}
show.autocor <- function(n = 5) {
sg.utm.autocor <- terra::autocor(sg4.utm[[1]],
w=make.weights(n, res(sg4.utm)[1], vmf.sg),
method="moran", global = FALSE)
terra::plot(sg.utm.autocor, main = paste("SG250, Moran's I", n, "x", n),
col = rev(hcl.colors(32, palette = "RdYlGn")))
}
#| label: moving-window
show.autocor(5)
show.autocor(7)
show.autocor(9)
range(values(sg4.utm[[1]], na.rm = TRUE))
sg4.quant <- cut(values(sg4.utm[[1]]), breaks = 16, labels = 0:15, include.lowest = TRUE)
table(sg4.quant)
# show the breakpoints
levels(cut(values(sg4.utm[[1]]), breaks = 16, include.lowest = TRUE))
sg4.utm.quant <- sg4.utm[[1]]
values(sg4.utm.quant) <- sg4.quant
plot(sg4.utm.quant, col = rainbow(16), main = paste(layer.names[1], ", 16 levels"))
#| label: example-glcm
# obtain the bounding box of the test area from cell numbers
xy <- xyFromCell(sg4.utm[[1]], cellFromRowCol(sg4.utm[[1]], 40:45, 40:45))
# crop to this box
w.sg <- crop(sg4.utm[[1]], xy)
test.quant <- cut(values(w.sg), breaks = 8,
labels = 0:7, include.lowest = TRUE)
# the classes of the cut
(l.8 <- levels(cut(values(w.sg), breaks = 8, include.lowest = TRUE)))
# add the class labels to the test map
w.sg.8 <- w.sg; values(w.sg.8) <- test.quant
# show the property and the derived grey levels together
par(mfrow = c(1,2))
plot(w.sg, main = "property value")
plot(w.sg.8, main = "grey level", col = grey.colors(8))
par(mfrow = c(1,1))
# set up the matrix on which to compute the GLCM
(test.matrix <- as.matrix(w.sg.8, wide = TRUE))
glcm <- GLCMTextures::make_glcm(test.matrix,
n_levels = 9, shift = c(1, 0), # shift one cell to the right
normalize = FALSE )
print(glcm)
sum(diag(glcm))/sum(glcm)
# convert to the older `raster` format
sg4.utm.raster <- raster(sg4.utm)
#| label: example-glcm
# obtain the bounding box of the test area from cell numbers
xy <- xyFromCell(sg4.utm[[1]], cellFromRowCol(sg4.utm[[1]], 40:45, 40:45))
# crop to this box
w.sg <- crop(sg4.utm[[1]], xy)
test.quant <- cut(values(w.sg), breaks = 8,
labels = 0:7, include.lowest = TRUE)
# the classes of the cut
(l.8 <- levels(cut(values(w.sg), breaks = 8, include.lowest = TRUE)))
# add the class labels to the test map
w.sg.8 <- w.sg; values(w.sg.8) <- test.quant
# show the property and the derived grey levels together
par(mfrow = c(1,2))
plot(w.sg, main = "property value")
plot(w.sg.8, main = "grey level", col = grey.colors(8))
par(mfrow = c(1,1))
# set up the matrix on which to compute the GLCM
(test.matrix <- as.matrix(w.sg.8, wide = TRUE))
glcm <- GLCMTextures::make_glcm(test.matrix,
n_levels = 9, shift = c(1, 0), # shift one cell to the right
normalize = FALSE )
print(glcm)
sum(diag(glcm))/sum(glcm)
stat.list <- c("mean","variance","homogeneity","contrast",
"entropy","dissimilarity","second_moment",
"correlation")
glcm.sg <- rast(glcm(sg4.utm.raster,
window = c(5, 5),
n_grey = 32, # number of levels in the GLCM
shift=list(c(0,1), c(1,1), c(1,0), c(1,-1)), # all directions
na_opt = "ignore",
statistics = stat.list))
class(glcm.sg)
summary(glcm.sg)
plot(glcm.sg)
plot(glcm.sg[["glcm_mean"]], main = "GLCM mean",
col=(sp::bpy.colors(32)))
plot(glcm.sg[["glcm_variance"]], main = "GLCM variance",
col=(cm.colors(32)))
plot(glcm.sg[["glcm_contrast"]], main = "Contrast",
col=(topo.colors(32)))
plot(glcm.sg[["glcm_dissimilarity"]], main = "Dissimilarity",
col=(topo.colors(32)))
plot(glcm.sg[["glcm_entropy"]], main = "Entropy",
col=(topo.colors(32)))
#| label: histo-equal
#| fig-width: 8
n.class <- 8
# combined values
values.sort <- sort(values(sg4.utm[[1]]))
range(values.sort)
# number of pixels not NA
n.nna <- length(values.sort) - sum(is.na(values.sort))
# how many pixels in each bin
(cut.positions <- round(n.nna/n.class))
# the cut positions
(cuts <- values.sort[cut.positions * 1:(n.class-1)])
# integer values for the cuts
cuts[1] <- floor(cuts[1]); cuts[n.class-1] <- ceiling(cuts[n.class-1])
cuts[2:n.class-2] <- round(cuts[2:n.class-2])
print(cuts)
hist(values.sort, breaks=36, main="Histogram equalization",
xlab = layer.names[1])
abline(v=cuts, col="blue", lwd=2)
#| label: classify-raster-hist
# `rcl` is a vector with the lowest limit 0, the cuts, and the maximum valie
#       so that all values are classified
sg4.class <- terra::classify(sg4.utm[[1]],
rcl= c(0, cuts, ceiling(max(values.sort))))
table(values(sg4.class))
names(sg4.class) <- "class"
#| label: show.classified-hist
terra::plot(sg4.class,
type="classes",
main=layer.names[1])
#| label: ph.classes
# find the layer number for this property
(ix.ph05 <- which(layer.names == "phh2o_0-5cm_mean"))
(cuts <- seq(floor(min(values(sg4.utm[[ix.ph05]], na.rm = TRUE))),
ceiling(max(values(sg4.utm[[ix.ph05]], na.rm = TRUE))),
by = 0.4))
#| label: classify-raster-cuts
sg.ph.class <- terra::classify(sg4.utm[[ix.ph05]], rcl= cuts)
table(values(sg.ph.class))
names(sg.ph.class) <- "class"
sink()
#| label: classify-raster-cuts
sg.ph.class <- terra::classify(sg4.utm[[ix.ph05]], rcl= cuts)
table(values(sg.ph.class))
names(sg.ph.class) <- "class"
#| label: show.classified-cuts
terra::plot(sg.ph.class,
col=sp::bpy.colors(length(cuts)), type="classes",
main="SG2 pH 0.2 units")
#| label: coma
coma.ph <- lsp_signature(sg.ph.class, type="coma", neighbourhood = 8)
head(coma.ph.matrix <- as.matrix(coma.ph$signature)[[1]])
# proportion with adjacent of the same class
sum(diag(coma.ph.matrix))/sum(coma.ph.matrix)
#| label: variogram_empirical
#| fig-width: 8
#| fig-height: 4
layer.names
sink()
#| label: variogram_empirical
#| fig-width: 8
#| fig-height: 4
layer.names
#| label: clay-map
#| fig-width: 8
(ix.clay05 <- which(layer.names == "clay_0-5cm_mean"))
# examine one `sf` object in the list
head(sg4.sf[[1]])
#| label: variogram_empirical
#| fig-width: 8
#| fig-height: 4
print(layer.names)
#| label:  metrics.cove
# normalized co-occurence vector 8 x 8
(cove.ph <- lsp_signature(sg.ph.class, type="cove", neighbourhood = 8))
#| label:  metrics.cove
# normalized co-occurence vector 8 x 8
print(cove.ph <- lsp_signature(sg.ph.class, type="cove", neighbourhood = 8))
# the co-occurrence vector
(cove.silt <- lsp_signature(sg.silt.class, type="cove", neighbourhood = 8))
#|.label: coma-cove
coma.silt <- lsp_signature(sg.silt.class, type="coma", neighbourhood = 8)
#| label: silt-map
#| fig-width: 8
(ix.silt05 <- which(layer.names == "silt_0-5cm_mean"))
summary(sg4.utm[[ix.silt05]])
(cuts <- seq(floor(min(values(sg4.utm[[ix.silt05]]-50, na.rm = TRUE))),
ceiling(max(values(sg4.utm[[ix.silt05]]+50, na.rm = TRUE))),
by = 50))
sg.silt.class <- terra::classify(sg4.utm[[ix.silt05]], rcl= cuts)
table(values(sg.silt.class))
names(sg.silt.class) <- "class"
plot(sg.silt.class, col = topo.colors(11),
main = layer.names[ix.silt05])
#|.label: coma-cove
coma.silt <- lsp_signature(sg.silt.class, type="coma", neighbourhood = 8)
print(coma.silt.matrix <- as.matrix(coma.silt$signature)[[1]])
sum(diag(coma.silt.matrix))/sum(coma.silt.matrix)
# the co-occurrence vector
(cove.silt <- lsp_signature(sg.silt.class, type="cove", neighbourhood = 8))
sink()
# the co-occurrence vector
(cove.silt <- lsp_signature(sg.silt.class, type="cove", neighbourhood = 8))
sum(diag(coma.silt.matrix))/sum(coma.silt.matrix)
#| label: distance-ph-silt
cove.df <- data.frame(cove.ph)$signature[[1]][1,]
cove.df <- rbind(cove.df, cove.silt$signature[[1]][1,])
cove.dists <- round(
philentropy::distance(cove.df, method = "jensen-shannon",
use.row.names =TRUE,
as.dist.obj = FALSE,
diag = FALSE) ,4)
print(cove.dists)
?distance
dim(incove.sg.dist)[1]
#| label: incove.dist
sg.ph.silt.class <- c(sg.ph.class, sg.silt.class)
incove.sg <- lsp_signature(sg.ph.silt.class,
type = "incove",
neighbourhood = 8,
ordered = TRUE,  # the pH classes are ordered
window = 16,
normalization = "pdf")  #sum to one
summary(incove.sg.dist <- lsp_to_dist(incove.sg,
dist_fun = "jensen-shannon"))
dim(incove.sg.dist)
p2 <- ggplot() +
tidyterra::geom_spatraster(data = sg.ph.class, aes(fill = class)) +
theme(legend.position="none", main = "pH class")
#| label: incove-clusters-map-3
p1 <- ggplot(data = sg.grid.sf) +
geom_sf(aes(fill = clust), alpha = 0.7) +
scale_fill_discrete(type = my.pal) +
labs(fill = "cluster")  +
theme(legend.position="none")
#| label: incove.cluster.cut
#| fig-width: 8
sg.clusters <- as.factor(cutree(sg.hclust, h = 0.5))  # cutpoint by visual inspection
#| label: incove.cluster
sg.hclust <- hclust(incove.sg.dist, method = "ward.D2")
plot(sg.hclust, main = "clusters of distance between `incove`")
#| label: incove.cluster.cut
#| fig-width: 8
sg.clusters <- as.factor(cutree(sg.hclust, h = 0.5))  # cutpoint by visual inspection
levels(sg.clusters)
sg.grid.sf = lsp_add_clusters(incove.sg, sg.clusters)
sg.grid.sf$clust <- as.factor(sg.grid.sf$clust)
my.pal <- colorRampPalette(brewer.pal(8, "Accent"))(length(levels(sg.grid.sf$clust)))
ggplot(data = sg.grid.sf) +
geom_sf(aes(fill = clust), alpha = 0.7) +
scale_fill_discrete(type = my.pal) +
labs(title = "Clusters: distance between integrated co-occurrence vectors",
fill = "cluster")
#| label: incove-clusters-map-3
p1 <- ggplot(data = sg.grid.sf) +
geom_sf(aes(fill = clust), alpha = 0.7) +
scale_fill_discrete(type = my.pal) +
labs(fill = "cluster")  +
theme(legend.position="none")
p2 <- ggplot() +
tidyterra::geom_spatraster(data = sg.ph.class, aes(fill = class)) +
theme(legend.position="none", main = "pH 0-5 cm class")
p3 <- ggplot() +
tidyterra::geom_spatraster(data = sg.silt.class, aes(fill = class)) +
theme(legend.position="none", main = "Silt 0-5 cm class")
gridExtra::grid.arrange(p1, p2, p3, nrow=1)
#| label: incove-clusters-map-3
p1 <- ggplot(data = sg.grid.sf) +
geom_sf(aes(fill = clust), alpha = 0.7) +
scale_fill_discrete(type = my.pal) +
labs(fill = "cluster")  +
theme(legend.position="none")
p2 <- ggplot() +
tidyterra::geom_spatraster(data = sg.ph.class, aes(fill = class)) +
theme(legend.position="none", labs(title = "pH 0-5 cm class"))
p3 <- ggplot() +
tidyterra::geom_spatraster(data = sg.silt.class, aes(fill = class)) +
theme(legend.position="none", main = "Silt 0-5 cm class")
gridExtra::grid.arrange(p1, p2, p3, nrow=1)
#| label: incove-clusters-map-3
p1 <- ggplot(data = sg.grid.sf) +
geom_sf(aes(fill = clust), alpha = 0.7) +
scale_fill_discrete(type = my.pal) +
labs(fill = "cluster")  +
theme(legend.position="none")
p2 <- ggplot() +
tidyterra::geom_spatraster(data = sg.ph.class, aes(fill = class)) +
theme(legend.position="none") +
labs(title = "pH 0-5 cm class"))
p2 <- ggplot() +
tidyterra::geom_spatraster(data = sg.ph.class, aes(fill = class)) +
theme(legend.position="none") +
labs(title = "pH 0-5 cm class")
#| label: incove-clusters-map-3
p1 <- ggplot(data = sg.grid.sf) +
geom_sf(aes(fill = clust), alpha = 0.7) +
scale_fill_discrete(type = my.pal) +
labs(fill = "cluster")  +
theme(legend.position="none")
p2 <- ggplot() +
tidyterra::geom_spatraster(data = sg.ph.class, aes(fill = class)) +
theme(legend.position="none") +
labs(title = "pH 0-5 cm class")
p3 <- ggplot() +
tidyterra::geom_spatraster(data = sg.silt.class, aes(fill = class)) +
theme(legend.position="none", main = "Silt 0-5 cm class")
gridExtra::grid.arrange(p1, p2, p3, nrow=1)
#| label: incove-clusters-map-3
p1 <- ggplot(data = sg.grid.sf) +
geom_sf(aes(fill = clust), alpha = 0.7) +
scale_fill_discrete(type = my.pal) +
labs(fill = "cluster")  +
theme(legend.position="none")
p2 <- ggplot() +
tidyterra::geom_spatraster(data = sg.ph.class, aes(fill = class)) +
theme(legend.position="none") +
labs(title = "pH 0-5 cm class")
p3 <- ggplot() +
tidyterra::geom_spatraster(data = sg.silt.class, aes(fill = class)) +
theme(legend.position="none") +
labs(title = "Silt 0-5 cm class")
gridExtra::grid.arrange(p1, p2, p3, nrow=1)
#| label: incove-clusters-map-3
p1 <- ggplot(data = sg.grid.sf) +
geom_sf(aes(fill = clust), alpha = 0.7) +
scale_fill_discrete(type = my.pal) +
labs(fill = "cluster", title = "INCOVE clusters")  +
theme(legend.position="none")
p2 <- ggplot() +
tidyterra::geom_spatraster(data = sg.ph.class, aes(fill = class)) +
theme(legend.position="none") +
labs(title = "pH 0-5 cm class")
p3 <- ggplot() +
tidyterra::geom_spatraster(data = sg.silt.class, aes(fill = class)) +
theme(legend.position="none") +
labs(title = "Silt 0-5 cm class")
gridExtra::grid.arrange(p1, p2, p3, nrow=1)
#| label: incove-clusters-map-3
p1 <- ggplot(data = sg.grid.sf) +
geom_sf(aes(fill = clust), alpha = 0.7) +
scale_fill_discrete(type = my.pal) +
labs(fill = "cluster", title = "INCOVE clusters")  +
theme(legend.position="none")
p2 <- ggplot() +
tidyterra::geom_spatraster(data = sg.ph.class, aes(fill = class)) +
theme(legend.position="none") +
labs(title = "pH 0-5 cm classes")
p3 <- ggplot() +
tidyterra::geom_spatraster(data = sg.silt.class, aes(fill = class)) +
theme(legend.position="none") +
labs(title = "Silt 0-5 cm classes")
gridExtra::grid.arrange(p1, p2, p3, nrow=1)
#| label: list_metrics_patch
head(landscapemetrics::list_lsm(level="patch") %>% print(n=Inf))
sink()
#| label: list_metrics_patch
head(landscapemetrics::list_lsm(level="patch") %>% print(n=Inf))
#| label: list_metrics_landscape
head(landscapemetrics::list_lsm(level="landscape") %>% print(n=Inf), 12)
#| label: list_metrics_class
head(landscapemetrics::list_lsm(level="class") %>% print(n=Inf), 12)
#| label: list_metrics_patch
head(landscapemetrics::list_lsm(level="patch") %>% print(n=Inf), 12)
#| label: list_metrics_patch
landscapemetrics::list_lsm(level="patch") %>% print(n = 12)
#| label: list_metrics_landscape
landscapemetrics::list_lsm(level="landscape") %>% print(n = 12)
#| label: list_metrics_class
landscapemetrics::list_lsm(level="class") %>% print(n = 12)
#| label: list_metrics_patch
landscapemetrics::list_lsm(level="patch") %>% print(n = 12)
#| label: supercells-not-compact
#| fig-width: 6
sg4.ph.50 = supercells(sg4.utm[[ix.ph05]], k = 50, compactness = 0.2)
names(sg4.ph.50)
names(sg4.ph.50)[4] <- "pH_05cm" # `supercells` changes the name -- a bug?
ggplot(data=sg4.ph.50) +
geom_sf(aes(fill = pH_05cm)) +
scale_fill_viridis_c() +
labs(fill = "mean pH")
#| label: supercells-compact
#| fig-width: 6
sg4.ph.50 = supercells(sg4.utm[[ix.ph05]], k = 50, compactness = 2)
names(sg4.ph.50)[4] <- "pH_05cm" # `supercells` changes the name -- a bug?
ggplot(data=sg4.ph.50) +
geom_sf(aes(fill = pH_05cm)) +
scale_fill_viridis_c() +
labs(fill = "mean pH")
#| label: supercells-compact
#| fig-width: 6
sg4.ph.50 = supercells(sg4.utm[[ix.ph05]], k = 50, compactness = 2)
names(sg4.ph.50)[4] <- "pH_05cm" # `supercells` changes the name -- a bug?
ggplot(data=sg4.ph.50) +
geom_sf(aes(fill = pH_05cm)) +
scale_fill_viridis_c() +
labs(fill = "mean pH")
#| label: supercells-compact
#| fig-width: 6
sg4.ph.50 = supercells(sg4.utm[[ix.ph05]], k = 50, compactness = 3)
names(sg4.ph.50)[4] <- "pH_05cm" # `supercells` changes the name -- a bug?
ggplot(data=sg4.ph.50) +
geom_sf(aes(fill = pH_05cm)) +
scale_fill_viridis_c() +
labs(fill = "mean pH")
#| label: supercells-not-compact
#| fig-width: 6
sg4.ph.50 = supercells(sg4.utm[[ix.ph05]], k = 50, compactness = 0.1)
names(sg4.ph.50)
names(sg4.ph.50)[4] <- "pH_05cm" # `supercells` changes the name -- a bug?
ggplot(data=sg4.ph.50) +
geom_sf(aes(fill = pH_05cm)) +
scale_fill_viridis_c() +
labs(fill = "mean pH")
#| label: supercells-multiple
#| fig-width: 6
r <- c(sg4.utm[[ix.ph05]], sg4.utm[[ix.silt05]])
r.50 = supercells(r, k = 50, compactness = 0.1)
ggplot(data=r.50) +
geom_sf(aes(fill = phh2o_0.5cm_mean)) +
labs(fill = "mean pH") +
scale_fill_continuous(type = "viridis")
ggplot(data=r.50) +
geom_sf(aes(fill = silt_0.5cm_mean)) +
labs(fill = "silt ppt") +
scale_fill_continuous(type = "viridis")
#| label: supercells-multiple
#| fig-width: 6
r <- c(sg4.utm[[ix.ph05]], sg4.utm[[ix.silt05]])
r.50 = supercells(r, k = 50, compactness = 0.1)
ggplot(data=r.50) +
geom_sf(aes(fill = phh2o_0.5cm_mean)) +
labs(fill = "mean pH") +
scale_fill_continuous(type = "viridis")
ggplot(data=r.50) +
geom_sf(aes(fill = silt_0.5cm_mean)) +
labs(fill = "silt ppt") +
scale_fill_continuous(type = "viridis")
#| label: r-packages-common
options(warn = -1)
# data wrangling
library(dplyr, warn.conflicts=FALSE, quiet = TRUE)
# colour palettes for graphics
library(RColorBrewer, warn.conflicts=FALSE, quiet = TRUE)
# ggplot graphics
library(ggplot2, warn.conflicts=FALSE, quiet = TRUE)
# multiple graphics in one plot
library(gridExtra, warn.conflicts=FALSE, quiet = TRUE)
#| label: r-package-spatia
# Robert Hijmans raster and vector data; also replaces `raster`
library(terra, warn.conflicts=FALSE, quiet = TRUE)
# ggplot with terra SpatRaster objects
library(tidyterra, warn.conflicts=FALSE, quiet = TRUE)
# older package still needed to convert to `sp` objects
library(raster, warn.conflicts=FALSE, quiet = TRUE)
# Pebesma et al. spatio-temporal data
# Simple Features
library(sf, warn.conflicts=FALSE, quiet = TRUE)
# `sp` spatial classes -- still needed for conversions
library(sp, warn.conflicts=FALSE, quiet = TRUE)
#| label: r-packages-workshop
# variogram modelling
library(gstat, warn.conflicts=FALSE, quiet = TRUE)
# Co-occurrence vectors
library(motif, warn.conflicts=FALSE, quiet = TRUE)
# multivariate distance metrics
library(philentropy, warn.conflicts=FALSE, quiet = TRUE)
# FRAGSTATS-style metrics
# this package is in active development, maybe use the development version
# install.packages("remotes")
# remotes::install_github("r-spatialecology/landscapemetrics")
library(landscapemetrics, warn.conflicts=FALSE, quiet = TRUE)
# utility functions for raster* landscape objects)
library(landscapetools, warn.conflicts=FALSE, quiet = TRUE)
# aggreagate maps with supercells
# this package is in active development, maybe use the development version
# install.packages("supercells", repos = "https://nowosad.r-universe.dev")
library(supercells, warn.conflicts=FALSE, quiet = TRUE)
# Gray Level Co-occurence Matrices (GLCM)
library(glcm, warn.conflicts=FALSE, quiet = TRUE)
library(GLCMTextures, warn.conflicts=FALSE, quiet = TRUE)
#| label: set-base-dir
file.dir <- path.expand("~/ds_reference/DSM2025/")
#| label: import
# the GeoTIFF file name
sg.fn <- "lat1011_lon7778_stack.tif"
(sg <- rast(paste0(file.dir, sg.fn)))
source("~/GitHub/Evaluating-Digital-Soil-Maps-by-their-patterns/PatternAnalysisWorkshop/InstallWorkshopPackages_2025.R")
?supercells
